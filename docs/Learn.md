
- [최종 일관성: Eventually Consistent][]
- [이벤트 소싱: Event Sourcing][]
- [EagerReadDerivation] 쿼리 측 모델 단순화
- [인증]
  - 세션
    1. 악의적인 공격자가 브라우저에 저장된 데이터를 탈취할 수 있음. 
    2. 비록 세션을 알 수 없는 문자열로 만들었다고 해도, http 는 보안에 취약하기 때문에 중간에 전달되는 데이터 역시 가로챌 가능성이 있음.
       이를 방지하기 위해 https 로 암호화 된 통신을 하고 세션에 유효시간을 둠. `session = { expire: now(), https }`
    3. 세션은 서버의 저장소에 저장되고 빠른 응답을 위해 메모리에 상주시키는 경우가 많음. -> 트래픽이 많은 경우 요청마다 세션 확인을 해야하므로 데이터베이스의 부하가 심해지고 메모리 부족 현상이 일어남.
       이를 위해 redis 를 이용해 메모리에 상주하는 세션을 이용하기도 함.
  - 토큰
    1. 토큰은 사용자가 로그인 했을 때 서버에서 토큰을 생성해서 전달하고 저장소에 저장하지 않음. 이후 요청에 대해 클라이언트가 전달한 토큰에 대해 검증만 수행을 하게 됌.
    2. JWT 방식을 많이 사용함.
    3. 세션처럼 상태를 관리할 필요가 없어 어느 도메인의 서비스로 보내더라도 같은 인증을 수행할 수 있게 됌.
        - JWT
          - prop
            - URL Safe, 간결함
            - 클레임을 디지털 방식으로 서명 또는 MAC(Message Authentication Code) 로 암호화되어 무결성을 보호
            - JSON 사용
          - 구성 요소
            - Header -> Base64 encoding `{"typ": "JWT", "alg": "HS256"}`
            - Payload -> Base64 encoding
              1. 등록된 클레임(Registered Claims)
                  iss: issuer(발급지)           -> 앱에서 정한 임의의 문자열 또는 URI 형식
                  sub: subject(주제)           -> 앱에서 정한 문자열 또는 URI 형식, 발급자가 정의하는 문맥상 또는 전역으로 유일한 값을 가져야 함
                  aud: Audience(수신자)         -> 누구에게 토큰이 전달되는 가를 나타냄. 주로 보호된 리소스의 URL 값으로 설정함.
                  exp: Expiration(만료 시간)    -> 언제 토큰이 만료되는 지 나타냄. 주로 UNIX EPOCH 시간을 사용함.
                  nbf: Not Before             -> 정의 된 시간 이후에 토큰이 활성화 됨. 토큰이 유효해지는 시간 이전에 미리 발급되는 경우 사용함. 주로 UNIX EPOCH 시간을 사용함. 
                  iat: Issued At(토큰 발급 시간) -> 언제 토큰이 발급되었는지를 나타냄. 주로 UNIX EPOCH 시간을 사용함.
                  jti: JWT ID, 토큰 식별자      -> 토큰의 고유 식별자로서 같은 값을 가질 확률이 없는 암호학적 방법으로 생성되어야 함. 탈취 방지
              2. 공개 클레임(Public Claims) JWT 발급자는 표준 클레임에 덧붙여 공개되어도 무방한 페이로드를 공개 클레임으로 정의 함. 이름 충돌을 방지하기 위해 IANA_JWT 클레임 레지스트리에 클레임 이름을
                                         등록하거나 합리적인 예방 조치를 취해야 함. 보통 URI 형식으로 함.
              3. 비공개 클레임(Private Claims) JWT 발급자와 사용자간에 사용하기로 약속한 클레임을 말함. 이름 충돌이 발생하지 않도록 주의해야 함.
            - Signature 생성된 토큰이 유효한 지 검증하는 장치임. 보통 secret 키를 말함.
    4. 로그인 시나리오
       로그인은 사용자가 이메일과 비밀번호를 입력하고 해당 서비스를 이용할 수 있도록 Resource 접근 권한을 주는 것이다. 토큰은 해커가 토큰을 탈취한 경우 토큰을 즉시 무효화 시키지 못하는 치명적인 보안 취약점을 가진다.
       따라서 사용자가 사용하는 토큰은 가능한 유효시간을 짧게 두게 된다. 하지만 너무 짧게두면, 만료된 토큰으로 유저가 접속할 경우 재 로그인 요청을 보내야 한다. 이런 경우들을 대비해 JWT 전략을 이용하게 된다.
       1. 슬라이딩 세션 -> 재 로그인을 하지 않고 현재 가지고 있는 토큰을 새로운 토큰으로 재발급하는 방식
       2. 리프레시 토큰 -> 이때 재발급하는 과정에서 필요한 토큰 유효시간은 리프레쉬 토큰으로 해결한다.
          1. 우선 사용자가 회원가입 할 때 토큰(AccessToken, RefreshToken)을 생성해 클라이언트에게 전달한다.
          2. 클라이언트는 Access Token 의 만료 여부를 판단하고, 만료 되었을 경우 Refresh Token 으로 로그인 요청을 하게 된다.
          3. 만약 만료되지 않았을 경우 Access Token 으로 서비스를 이용한다.
          4. 로그인 요청 시, 헤더에 AccessToken: expired 라면, 토큰 서비스에 Access Token 을 재발급하라는 이벤트를 남긴다.
          5. 로그인 성공 시, 유저는 새 Access Token 을 발급받게 된다. 만약 헤더에 RefreshToken: expired 라면 토큰 서비스의 Refresh Token 을 재 발급하라는 이벤트를 남긴다.
          6. 여기서 RTR 기법을 적용해, 만약 Access Token 이 만료가 되었을 때, Refresh Token 으로 로그인 요청을 하게 되면,
             1. Access Token 을 재 발급하고,
             2. Refresh Token 도 재 발급해서,
             3. 클라이언트의 안전한 보관소에 있는 Refresh Token 을 업데이트 한다 <- 해커가 가지고 있는 Refresh Token 과 현재 재발급받은 유저의 Refresh Token 은 서로 다르다.
          7. Access Token 의 만료 시간은 현재 테스트 중이므로 10분으로 둔다. (Production: 24 hour)
          8. Refresh Token 의 만료 시간은 현재 테스트 중이므로 1시간으로 둔다. (Production: 6 month)
          9. 여기서 RTR 기법을 적용하면, 만료시간은 어떻게 되지?, Refresh Token 탈취가 아니라 지속적인 Access Token 탈취가 이루어지면 어떻게 되지?
          10. 클라이언트는 Access Token 과 Refresh Token 의 보안 취약점으로부터 벗어나기 위해 안전한 저장소에 토큰을 담아 둔다.
              1. Mobile application:
              2. Web application:
          11. 만약 토큰이 탈취되었을 경우
              1. 모든 토큰을 전부 무효화 해야 한다. -> 해커가 유효한 Refresh Token 으로 Resource 접근을 할 수 있으므로
              2. 만약 해킹 당했을 경우 -> 유저가 직접 토큰을 삭제할 수 있어야 한다 (방안 마련)
              3. 토큰을 탈취당했다는 것을 알 수 있는 방법 또는 기준이 무엇인가? (애플리케이션 보안에 대해 공부)
              4. RTR(Refresh Token Rotation) 기법 -> One Time Use Only 
  - [csrf](https://junhyunny.github.io/information/security/spring-boot/spring-security/cross-site-reqeust-forgery/)
    1. 사용자가 보안이 취약 서버로부터 이미 인증을 받은 상태.
    2. 쿠키 기반으로 서버 세션 정보를 획득할 수 있어야 함.
    3. 공격자는 서버를 공격하기 위한 요청 방법에 대해 미리 파악하고 있어야 함. url 파라미터에 대해 미리 숙지 필요.
    4. 시나리오
       1. 사용자 로그인
       2. 사용자의 세션 정보가 브라우저 쿠키에 담김
       3. 해커는 인증된 사용자가 악성 스크립트 페이지를 누르도록 유도.
            1. 악성 게시글 클릭
            2. 스팸 메일
       4. 누르면, 세션 아이디는 브라우저에 의해서 자동으로 서버로 요청됌.
       5. 서버는 쿠키에 담긴 세션 정보를 보고 사용자를 허용해줌. (해커는 내가 원하는 정보를 사용자의 세션정보를 이용해서 탈취하는 것을 말함. 악성 스크립트는 해커가 심어 놓은 fetch(url) 라고 생각해도 무방함.)
       6. fetch 또는 요청이 담긴 스크립트를 사용자가 클릭했을 떄, 브라우저는 서버로 요청을 보내게 되는데, 인증된 사용자의 이름으로 악성 스크립트 api 를 보내는거임. 기본적으로 HTTP 메서드의 기본 CSRF 탈취 시나리오가 존재함.
       7. 탈취 예방: 
          1. Referrer 검증: Request Header 의 Referer === Host 와 같기 때문에 이것만 검증해도 거의 방어가 가능
          2. CSRF 토큰 검증
          3. Double Submit Cookie 검증
  - [xss]()
    - Reflected XSS
    - Stored XSS
    - DOM Based XSS
  - [sql injection]()
    - 웹 응용 프로그램에 SQL 구문을 삽입해서, 내부 데이터베이스 서버의 데이터를 유출하거나 변조하는 공격을 말함.
    - 쿼리 조작, 마스터 계정으로 접근해서 데이터 베이스 조작을 하는 것을 말함.